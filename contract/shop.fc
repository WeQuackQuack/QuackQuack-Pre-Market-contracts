#pragma version >=0.2.0;

#include "../common/stdlib.func";
#include "../common/utils.func";
#include "../common/messages.func";
#include "utils/shop-storage.fc";
#include "utils/constants.fc";

(int) get_price(int tier) {
    (slice payload, int success) = storage::tier_dict.udict_get?(8, tier);
    throw_unless(ERR_TIER_INVALID, success);
    return payload~load_coins();
}

(int) get_next_price() impure {
    int price = 0;
    var checker = false;
    do {
        (slice payload, int success) = storage::tier_dict.udict_get?(8, storage::current_tier);
        throw_unless(ERR_TIER_INVALID, success);
        price = payload~load_coins();
        int max = payload~load_uint(64);
        checker = storage::total_sale < max;
        storage::current_tier += checker ? 0 : 1;
    } until (checker);
    return price;
}

(int) verify_signature(int op, int query_id, int request_id, int user_id, int expired_time, slice signature) impure {
    var payload = begin_cell()
        .store_uint(op, 32)
        .store_uint(query_id, 64)
        .store_uint(request_id, 64)
        .store_uint(user_id, 64)
        .store_uint(expired_time, 64)
        .end_cell();

    return check_signature(cell_hash(payload), signature, storage::pubKey);
}

() verify_sale_info(int user_id) impure {
    var ds = storage::sale_info.begin_parse();
    int max_supply = ds~load_uint(64);
    int max_per_user = ds~load_uint(64);
    int start_time = ds~load_uint(64);
    int end_time = ds~load_uint(64);
    int user_bought = 0;
    throw_unless(ERR_NFT_SOLDOUT, storage::total_sale < max_supply);
    throw_unless(ERR_SALE_NOT_START, now() >= start_time);
    throw_unless(ERR_SALE_ENDED, end_time >= now());
    (slice payload, int success) = storage::sale_dict.udict_get?(64, user_id);
    if (success) {
        user_bought = payload~load_uint(64);
        throw_unless(ERR_NFT_USER_MAX, user_bought < max_per_user);
    }
    user_bought += 1;
    storage::sale_dict~udict_set(64, user_id,
        begin_cell()
            .store_uint(user_bought, 64)
            .end_cell().begin_parse()
    );
}

(slice, int, int, int) get_buy_arguments(slice in_msg_body) impure {
    slice signature = in_msg_body~load_bits(512);
    int request_id = in_msg_body~load_uint(64);
    int user_id = in_msg_body~load_uint(64);
    int expired_time = in_msg_body~load_uint(64);
    return (signature, request_id, user_id, expired_time);
}

() request_mint(slice sender_address) impure {
    var mint_body = begin_cell()
        .store_uint(OP_MINT_NFT_AUTO, 32)
        .store_uint(0, 64) ;; query
        .store_coins(BASE_FEE_MINT_NFT)
        .store_slice(sender_address)
        .end_cell();

    send_simple_message(MINT_REQUEST_FEE, storage::collection, mint_body, NORMAL | IGNORE_ERRORS);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    var cs = in_msg_full.begin_parse();
    var flags = cs~load_uint(4);

    if (flags & 1) {
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    cs~load_msg_addr(); ;; skip dst
    cs~load_coins(); ;; skip value
    cs~skip_bits(1); ;; skip extracurrency collection
    cs~load_coins(); ;; skip ihr_fee

    load_data();

    (int op, int query_id) = (in_msg_body~load_uint(32), in_msg_body~load_uint(64));

    if (op == OP_BUY_NFT) {
        (slice signature, int request_id, int user_id, int expired_time) = get_buy_arguments(in_msg_body);
        throw_unless(ERR_REQUEST_EXPIRED, now() < expired_time);
        throw_unless(ERR_SIGNATURE_INVALID, verify_signature(op, query_id, request_id, user_id, expired_time, signature));
        verify_sale_info(user_id);

        int price = get_next_price();

        throw_unless(ERR_VALUE_NOT_ENOUGHT, msg_value >= price + MINT_REQUEST_FEE + MIN_GAS_EXECUTE);
        storage::total_sale += 1;
        save_data();
        request_mint(sender_address);
        return ();
    }

    ;; only owner
    throw_unless(ERR_NOT_OWNER, equal_slices(storage::owner, sender_address));

    if (op == OP_WITHDRAW_TON) {
        send_simple_message(0, sender_address, begin_cell().end_cell(), CARRY_ALL_BALANCE | IGNORE_ERRORS);
        return ();
    }

    if (op == OP_UPGRADE) {
        set_code(in_msg_body~load_ref());
        return ();
    }

    if (op == OP_UPDATE_PRICE) {
        int tier = in_msg_body~load_uint(8);
        int price = in_msg_body~load_coins();
        int limit = in_msg_body~load_uint(64);
        load_data();
        storage::tier_dict~udict_set(8, tier,
            begin_cell()
                .store_coins(price)
                .store_uint(limit, 64)
                .end_cell().begin_parse()
        );
        save_data();
    }

    if (op == OP_UPDATE_COLLECTION) {
        slice collection = in_msg_body~load_msg_addr();
        load_data();
        storage::collection = collection;
        save_data();
    }

    if (op == OP_UPDATE_SALE) {
        int max_supply = in_msg_body~load_uint(64);
        int max_per_user = in_msg_body~load_uint(64);
        int start_time = in_msg_body~load_uint(64);
        int end_time = in_msg_body~load_uint(64);
        load_data();
        storage::sale_info = begin_cell()
            .store_uint(max_supply, 64)
            .store_uint(max_per_user, 64)
            .store_uint(start_time, 64)
            .store_uint(end_time, 64)
            .end_cell();
        save_data();
    }
}

int get_current_price() method_id {
    load_data();
    (slice payload, int success) = storage::tier_dict.udict_get?(8, storage::current_tier);
    throw_unless(ERR_TIER_INVALID, success);
    return payload~load_coins();
}

int get_price_by_tier(int tier) method_id {
    load_data();
    return get_price(tier);
}

int get_user_bought(int user_id) method_id {
    load_data();
    (slice payload, int success) = storage::sale_dict.udict_get?(64, user_id);
    return success ? payload~load_uint(64) : 0;
}

(int, int, int, int, int, int, int) get_sale_info(int user_id) method_id {
    load_data();
    var ds = storage::sale_info.begin_parse();
    int max_supply = ds~load_uint(64);
    int max_per_user = ds~load_uint(64);
    int total_sale = storage::total_sale;
    int start_time = ds~load_uint(64);
    int end_time = ds~load_uint(64);
    int user_bought = 0;
    (slice payload, int success) = storage::sale_dict.udict_get?(64, user_id);
    if (success) {
        user_bought = payload~load_uint(64);
    }
    int price = get_next_price();
    return (max_supply, max_per_user, total_sale, start_time, end_time, user_bought, price);
}
